{"componentChunkName":"component---src-templates-blogpost-index-js","path":"/blog/brick-a-build-tool-for-mono-repositories/","result":{"data":{"site":{"siteMetadata":{"title":"TBD","author":"Olivier Corradi","siteUrl":"https://oliviercorradi.me","social":{"twitter":"corradio","linkedin":"oliviercorradi"}}},"markdownRemark":{"id":"c7ec7c2a-dd7f-50c1-b6d7-7157f858b63c","excerpt":"More and more organisations are embracing mono-repositories as it makes dependency management simpler (read more here).\nHowever, implementing and maintaining a…","html":"<p>More and more organisations are embracing mono-repositories as it makes dependency management simpler (read more <a href=\"https://danluu.com/monorepo/\">here</a>).\nHowever, implementing and maintaining a mono-repository at scale has its challenges.\nThis is due to the fact that building and testing a large repository is no simple feat.\nAt the core is a question of performance: at each commit, we need to re-build and re-test the whole repository.\nThat sounds very expensive, and therefore, a caching mechanism should be introduced.\nThe question then becomes: how do we find out which parts we need to rebuild and retest?</p>\n<p>Larger organisations such as Google, Facebook and Twitter have adopted the mono-repository approach as they have the means to maintain such an infrastructure, but unfortunately solutions for smaller organisations are limited.\nAt Tomorrow, we wanted to embrace the mono-repository structure.\nThis post explains why we built <a href=\"https://github.com/tmrowco/brick\">brick</a>, our home-made build tool for mono-repositories.</p>\n<h2>A small example</h2>\n<p>One of our products is <a href=\"https://www.electricitymap.org\">electricityMap</a>.\nIt shows in real-time the origin of electricity used across the world, alongside its carbon footprint.\nWe have a paid <a href=\"https://api.electricitymap.org\">API</a> which provides forecasts enabling anyone to optimise their electricity usage to reduce cost and emissions.\nelectricityMap is divided into geographical <em>zones</em> that are defined in a definition file called <code class=\"language-text\">zones.json</code>.\nThis definition file contains bounding boxes, data acquisition parameters and much more (I encourage you to take a look at it <a href=\"https://github.com/tmrowco/electricitymap-contrib/blob/master/config/zones.json\">here</a>).</p>\n<p>In our mono-repository, we have a multitude of micro-services, that are represented as folders in our repository. Here are some of them:</p>\n<ul>\n<li><code class=\"language-text\">api</code>: The backend which hosts our backend API</li>\n<li><code class=\"language-text\">api/www</code>: The <a href=\"https://api.electricitymap.org\">paid API website</a></li>\n<li><code class=\"language-text\">contrib</code>: A <a href=\"https://git-scm.com/book/en/v2/Git-Tools-Submodules\">git submodule</a> which points to the <a href=\"https://github.com/tmrowco/electricitymap-contrib\">open-source electricityMap frontend</a></li>\n<li><code class=\"language-text\">forecasting</code>: The forecasting pipeline used by the API</li>\n<li><code class=\"language-text\">weather</code>: The weather forecast fetching service used by the forecasting pipeline</li>\n</ul>\n<p>We use continuous deployment, which means that each pull request that changes the <code class=\"language-text\">zones.json</code> definition will update several systems in one go:</p>\n<ul>\n<li>the public <a href=\"https://www.electricitymap.org\">www.electricitymap.org</a> frontend is updated with the new geometries</li>\n<li>our weather forecast fetching service is updated to aggregate weather data over that new geometry using the bounding boxes provided</li>\n<li>our forecasting pipeline (part of our paid API) is updated</li>\n<li>our <a href=\"https://api.electricitymap.org\">API website</a> is updated to show availability of data (see figure)</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.2972972972973%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAIAAAC9o5sfAAAACXBIWXMAAAsSAAALEgHS3X78AAABlElEQVQoz2VR30vCUBT2n+ip1/6CIKiHgqB/JIgogkDwwTAC66GXgqKeIgjCQkSo6DWtCLInjWq1TSeYyGZrc85d3HZ3V9/VhMAD9+yeH9/Z+b4b+Rky36cBCz2f2g5p207X9VzPDxgb7ozghGEIHwSB0zPf93X9q9VqURqEA3MIyWQvDMPsh5RS+AghpN1uq6qqKNVGo1GtVg3DEAShUqlg4sub8CFKlmUtrUQnpmbf3z8+P2toBoT/GQXD+C6WSkfHJ4XCk6ZpzWbTNE1d1zudTmJjMxqLx+KJkdGx8cmZXD4vSaIsy0BxMGPM8zzs8Pom7O0f7u4dFIslZFDL3d4vLq9OTs8lt7Z3dvfnF5ZPU+eW1ep2u+DI18YHrfC2bafO0mvrSVVrIgTzx8LTTS5/eXUNCiAiy1KPlAnCqP6BcQOeBQxsVVXDFGRc1y3LsiiKiqJAi2LpuVwum1xFjvwTDGvTgXFVHSedyd7dPzDGxa/VavV6HbL33oJgLnamvZiDcdg/402EdBynX0ZmuKF/gSi/EQfgXz2JidoAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"emapapi\"\n        title=\"emapapi\"\n        src=\"/static/971bd6113f985c088fd48bdbc1a41bd3/fcda8/emapapi.png\"\n        srcset=\"/static/971bd6113f985c088fd48bdbc1a41bd3/12f09/emapapi.png 148w,\n/static/971bd6113f985c088fd48bdbc1a41bd3/e4a3f/emapapi.png 295w,\n/static/971bd6113f985c088fd48bdbc1a41bd3/fcda8/emapapi.png 590w,\n/static/971bd6113f985c088fd48bdbc1a41bd3/efc66/emapapi.png 885w,\n/static/971bd6113f985c088fd48bdbc1a41bd3/c83ae/emapapi.png 1180w,\n/static/971bd6113f985c088fd48bdbc1a41bd3/29007/emapapi.png 1600w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p class=\"figcaption\">This map on our <a href=\"https://api.electricitymap.org\">API website</a> is automatically updated each time we change the zones definition. The reason is that the map component is re-used between our <a href=\"https://api.electricitymap.org\">API website</a> and the <a href=\"https://www.electricitymap.org\">electricityMap frontend</a>.</p>\n<p>This is in stark contrast with a multi-repository setting, where one would first update and release a new version of the <code class=\"language-text\">zones.json</code> definition, then, for each dependent service, submit a pull request to update the <code class=\"language-text\">zones.json</code> dependency.\nThis is quite cumbersome and doesn’t scale well.\nHaving a single repository enables us to submit a pull request representing a single atomic change.\nIt enables us to move faster, keep a very modular codebase and increase the amount of code shared.</p>\n<h2>Build performance</h2>\n<p>The issue faced by mono-repositories  is that building and testing takes time as all build steps and tests need to be run, caused by the fact that it is not known which changes affect which builds and/or tests.\nSeveral tools address this need, like <a href=\"https://bazel.build/\">Bazel</a> used at Google, <a href=\"https://buck.build/\">Buck</a> at Facebook or <a href=\"https://www.pantsbuild.org/\">Pants</a> at Twitter (see a longer list <a href=\"https://github.com/korfuri/awesome-monorepo\">here</a>).\nThe problem is that those tools require a steep learning curve for new developers.\nWe wanted to simplify that drastically.</p>\n<h2>Requirements</h2>\n<p>When designing and assessing existing build tools, we looked at the following requirements:</p>\n<ul>\n<li>Any developer should be able to write a build definition with minimal learning</li>\n<li>The builds should be hermetic (missing a build input should trigger an error)</li>\n<li>The builds should be reproducible (triggering the same build on two machines should give the same output)</li>\n<li>The builds should be fast (changing only a few files should only rebuild and retest the relevant parts)</li>\n</ul>\n<p>Bazel came the closest, but after trying it out for a few weeks, we discovered that support for the Javascript toolkit was limited, and that writing build definitions was too complicated for our needs.\nWe were afraid that it would limit its adoption inside our team: we wanted something much simpler.</p>\n<h2>Enters <a href=\"https://github.com/tmrowco/brick\">brick</a>, based on Docker</h2>\n<p>It turns out that <a href=\"https://github.com/moby/buildkit\">buildkit</a>, the system building Docker images, already fulfills a lot of these requirements:</p>\n<ul>\n<li>Builds are hermetic, as they run in an isolated container</li>\n<li>Builds are deterministic as long as the same base image is used</li>\n<li>Incremental builds are possible as Docker caches steps already executed</li>\n</ul>\n<p>A small CLI called <a href=\"https://github.com/tmrowco/brick\">brick</a> was then built in Python.\nIt searches for a <code class=\"language-text\">BUILD.yaml</code> build definition file and then passes all relevant flags to the buildkit build engine.</p>\n<p>As an example, here’s the <code class=\"language-text\">BUILD.yaml</code> file we use to build and deploy our API website from the <code class=\"language-text\">./api</code> folder of our monorepo:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\"><span class=\"token key atrule\">name</span><span class=\"token punctuation\">:</span> www\n\n<span class=\"token key atrule\">steps</span><span class=\"token punctuation\">:</span>\n\n  <span class=\"token key atrule\">prepare</span><span class=\"token punctuation\">:</span>\n    <span class=\"token comment\"># This is the docker image that will be used (optional)</span>\n    <span class=\"token key atrule\">image</span><span class=\"token punctuation\">:</span> node<span class=\"token punctuation\">:</span><span class=\"token number\">10.3</span>\n    <span class=\"token comment\"># These are the commands that will be run</span>\n    <span class=\"token key atrule\">commands</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> yarn\n    <span class=\"token comment\"># Failing to declare those inputs will cause the `yarn`</span>\n    <span class=\"token comment\"># command to fail due to missing files</span>\n    <span class=\"token key atrule\">inputs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> package.json\n      <span class=\"token punctuation\">-</span> yarn.lock\n\n  <span class=\"token key atrule\">build</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">commands</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> yarn lint\n      <span class=\"token punctuation\">-</span> yarn build\n    <span class=\"token key atrule\">inputs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> static/\n      <span class=\"token punctuation\">-</span> src/\n      <span class=\"token punctuation\">-</span> gatsby<span class=\"token punctuation\">-</span><span class=\"token important\">*.js</span>\n      <span class=\"token punctuation\">-</span> .eslintrc.js\n    <span class=\"token comment\"># Outputs will be copied from the image to the host</span>\n    <span class=\"token key atrule\">outputs</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> public</code></pre></div>\n<p>Running the build is as easy as running <code class=\"language-text\">brick build</code> from that folder.\nFor each stage, if the commands have not changed and the inputs have not changed, then the build results are read from cache (this is done by the docker engine itself, which will cache <code class=\"language-text\">ADD</code> and <code class=\"language-text\">RUN</code> steps).\nUnder the hood, what actually happens is that brick generates a temporary Dockerfile that it builds.</p>\n<p>Once the build is done, <code class=\"language-text\">brick</code> reads the outputs array defined in the <code class=\"language-text\">BUILD.yaml</code> and copies the files from the image to the host machine.\nVoilà!</p>\n<h2>Speed</h2>\n<p>A no-op build with ~15 targets (i.e. micro-services) runs in 30seconds on our CI server (n1-standard-2 on Google Cloud Compute Engine).</p>\n<h2>Dependencies</h2>\n<p>As inputs and outputs are clearly defined, dependencies can automatically be detected: if an input intersects the output of another build, then that other build will automatically be triggered.</p>\n<h2>Development</h2>\n<p>Starting to work on a new target is as simple as running <code class=\"language-text\">brick develop</code>, given that the right configuration is added to <code class=\"language-text\">BUILD.yaml</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">  <span class=\"token key atrule\">develop</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">command</span><span class=\"token punctuation\">:</span> yarn develop <span class=\"token punctuation\">-</span>H 0.0.0.0\n    <span class=\"token key atrule\">ports</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> <span class=\"token number\">8000</span></code></pre></div>\n<p>What happens under the hood is that a <code class=\"language-text\">docker run</code> command is issued, re-using the <code class=\"language-text\">prepare</code> step to make sure every developer has the same dependencies.\nUsing our API website as an example, if a new dependency is added to the <code class=\"language-text\">package.json</code> file, then <code class=\"language-text\">brick develop</code> will automatically re-run the <code class=\"language-text\">prepare</code> step.\nThis avoids the problem of developers having to remember to run <code class=\"language-text\">yarn</code> if dependencies have changed.\nFurthermore, it guarantees that developers are always working on a consistent system.</p>\n<p><code class=\"language-text\">brick develop</code> runs in an isolated container, and automatically mounts volumes to the host filesystem based on the inputs declarations.\nThis ensures that watching file changes works, while still keeping the guarantee that missing inputs will cause errors, forcing the developer to declare them all.</p>\n<h2>Tests</h2>\n<p>Tests can also be defined in a similar fashion:</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">  <span class=\"token key atrule\">test</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">commands</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> yarn test</code></pre></div>\n<h2>Deployment</h2>\n<p>Deployments can also be cached.\nIn this example, we define a deployment configuration which copies the output of our build step (the <code class=\"language-text\">public</code> folder) to a Google Cloud Bucket.\nSecrets are also defined, which will be mounted during the deployment stage.</p>\n<div class=\"gatsby-highlight\" data-language=\"yml\"><pre class=\"language-yml\"><code class=\"language-yml\">  <span class=\"token key atrule\">deploy</span><span class=\"token punctuation\">:</span>\n    <span class=\"token key atrule\">commands</span><span class=\"token punctuation\">:</span>\n      <span class=\"token punctuation\">-</span> gsutil <span class=\"token punctuation\">-</span>m cp <span class=\"token punctuation\">-</span>a public<span class=\"token punctuation\">-</span>read <span class=\"token punctuation\">-</span>r public/* gs<span class=\"token punctuation\">:</span>//static.electricitymap.org/api\n    <span class=\"token key atrule\">secrets</span><span class=\"token punctuation\">:</span>\n      <span class=\"token key atrule\">gcloud</span><span class=\"token punctuation\">:</span>\n        <span class=\"token key atrule\">src</span><span class=\"token punctuation\">:</span> ~/.config/gcloud\n        <span class=\"token key atrule\">target</span><span class=\"token punctuation\">:</span> /root/.config/gcloud</code></pre></div>\n<h2>Final words</h2>\n<p><a href=\"https://github.com/tmrowco/brick\">brick</a> is still very experimental, and the documentation sparse.\nHowever it is already used internally for all of our builds and tests.\nIf you feel like you want to help us out make it more robust, please reach out on our <a href=\"https://slack.tmrow.com\">Slack</a> or join the conversation on <a href=\"https://github.com/tmrowco/brick\">Github</a>!</p>","fields":{"slug":"/brick-a-build-tool-for-mono-repositories/","readingTime":{"text":"7 min read"}},"frontmatter":{"title":"Brick: a build tool for mono-repositories","date":"March 23, 2020","description":"Introducing Brick as a new experimental tool for building mono-repositories","noheaderimage":null,"image":{"publicURL":"/static/6e9428f3e0b45388fc2f8d978b3f3954/cover.jpg","childImageSharp":{"fluid":{"aspectRatio":1.5,"src":"/static/6e9428f3e0b45388fc2f8d978b3f3954/1a900/cover.jpg","srcSet":"/static/6e9428f3e0b45388fc2f8d978b3f3954/18e3d/cover.jpg 480w,\n/static/6e9428f3e0b45388fc2f8d978b3f3954/c85f0/cover.jpg 960w,\n/static/6e9428f3e0b45388fc2f8d978b3f3954/1a900/cover.jpg 1920w,\n/static/6e9428f3e0b45388fc2f8d978b3f3954/df5b8/cover.jpg 2880w,\n/static/6e9428f3e0b45388fc2f8d978b3f3954/29a23/cover.jpg 3840w,\n/static/6e9428f3e0b45388fc2f8d978b3f3954/de9c6/cover.jpg 4000w","sizes":"(max-width: 1920px) 100vw, 1920px"}}}}}},"pageContext":{"slug":"/brick-a-build-tool-for-mono-repositories/","previous":{"fields":{"slug":"/banks-on-north/"},"frontmatter":{"title":"Why we removed the ability to connect your bank account to North and what we learnt on the way"}},"next":{"fields":{"slug":"/how-companies-reduce-their-carbon-footprint-with-electricitymap-api/"},"frontmatter":{"title":"How companies reduce their carbon footprint with electricityMap API"}}}},"staticQueryHashes":["1052764262","3128451518"]}